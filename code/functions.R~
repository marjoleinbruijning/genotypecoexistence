
################################################################################
## Functions
################################################################################

################################################################################
## Vital rates
################################################################################
## Model selection for each vital rate, and return only best model
selectmodel <- function (allmods) {

    modname <- deparse(substitute(allmods))

    npar <- unlist(lapply(allmods,function(x) nrow(fixef(x))))
    loo <- eval(parse(text=c('loo_compare(',c(paste0(modname,'[[',1:(length(allmods)-1),']],'),
                                              paste0(modname,'[[',(length(allmods)),']]')),
                             ')')))
    names(npar) <- paste0(modname,'[[',1:(length(allmods)),']]')


    ## Compare only model 1 with model 5
    ## loo <- eval(parse(text=c('loo_compare(',c(paste0(modname,'[[',1,']],'),
    ##                                          paste0(modname,'[[',(length(allmods)),']]')),
    ##                         ')')))
    ##inc <- which(abs(loo[,1]) < 4)
    ##return(allmods[[min(as.numeric(substr(rownames(loo)[inc],nchar(modname)+3,nchar(modname)+3)))]])
 
    
    ## Best model if significant
    ##inc <- !apply(loo[,1:2],1,function(x) .5*x[2] < abs(x[1])) ## all models not significantly worse than best (1SE!)
    ##namess <- names(inc[which.min(npar[as.numeric(substr(names(inc),nchar(modname)+3,nchar(modname)+3))])])
    ##return(allmods[[readr::parse_number(namess)]])

    ## Delta ELPD = 4 as threshold
    ##inc <- which(abs(loo[,1]) < 4) 
    ##namess <- names(which.min(npar[names(inc)]))
    ##return(allmods[[readr::parse_number(namess)]])

    ## Most complex model
    ##return(allmods[[5]])
    
    ## Just best model
    namess <- rownames(as.matrix(loo))[[1]]
    return(allmods[[readr::parse_number(namess)]]) # return only best model
}

################################################################################
## IPM functions
################################################################################
pxy <- function (mod=modSurv,predeffect='mean',df,ndraws=1) {

    reform <- ifelse(is.na(df$clone[1]),NA,'~(1|clone)')
    if (predeffect == 'mean') {
        pred <- t(fitted(mod,df,type='response',re_formula=reform)[,1,drop=FALSE])
    } else if (predeffect == 'posterior') {
        ##pred <- (posterior_predict(mod,df,ndraws=ndraws,re_formula=reform))
        pred <- (posterior_linpred(mod,transform=TRUE,df,ndraws=ndraws,re_formula=reform))
    } else if (predeffect == 'glm') {
        pred <- predict(mod,df,type='response')
    }

    return(pred)
}

gxy <- function (mod=modGrowth,predeffect='mean',df,ndraws=1) {

    reform <- ifelse(is.na(df$clone[1]),NA,'~(1|clone)')

    if (predeffect == 'mean') {
        pred <- t((fitted(mod,df,re_formula=reform)[,1,drop=FALSE]))
    } else if (predeffect == 'posterior') {
        ##pred <- (posterior_predict(mod,df,ndraws=ndraws,re_formula=reform))
        pred <- (posterior_linpred(mod,transform=TRUE,df,ndraws=ndraws,re_formula=reform))
    } else if (predeffect == 'glm') {
        pred <- predict(mod,df,type='response')
    }

    return(pred)
}


fxy1 <- function (mod=modEggs,predeffect='mean',df,ndraws=1) {

    reform <- ifelse(is.na(df$clone[1]),NA,'~(1|clone)')

    if (predeffect == 'mean') {
        R1 <- t(fitted(mod,df,type='response',re_formula=reform)[,1,drop=FALSE])
    } else if (predeffect == 'posterior') {
        ##R1 <- (posterior_predict(mod,df,type='response',ndraws=ndraws,re_formula=reform))
        R1 <- (posterior_linpred(mod,transform=TRUE,df,ndraws=ndraws,re_formula=reform))
    } else if (predeffect == 'glm') {
        R1 <- predict(mod,df,type='response')
    }

    return(R1)
}

fxy2 <- function (mod=modRepr,predeffect='mean',df,ndraws=1) {

    reform <- ifelse(is.na(df$clone[1]),NA,'~(1|clone)')

    if (predeffect == 'mean') {
        R2 <- t(fitted(mod,df,type='response',re_formula=reform)[,1,drop=FALSE])
    } else if (predeffect == 'posterior') {
        ##R2 <- (posterior_predict(mod,df,type='response',ndraws=ndraws,re_formula=reform))
        R2 <- (posterior_linpred(mod,transform=TRUE,df,ndraws=ndraws,re_formula=reform))
    } else if (predeffect == 'glm') {
        R2 <- predict(mod,df,type='response')
    }

    return(R2)
}

fxy3 <- function (mod=modClutch,predeffect='mean',df,ndraws=1) {

    reform <- ifelse(is.na(df$clone[1]),NA,'~(1|clone)')

    if (predeffect == 'mean') {
        R3 <- t(fitted(mod,df,type='response',re_formula=reform)[,1,drop=FALSE] + 1)
    } else if (predeffect == 'posterior') {
        ##R3 <- (posterior_predict(mod,df,type='response',ndraws=ndraws,re_formula=reform) + 1)
        R3 <- (posterior_linpred(mod,transform=TRUE,df,ndraws=ndraws,re_formula=reform) + 1)
    } else if (predeffect == 'glm') {
        R3 <- predict(mod,df,type='response')
    }

    return(R3)
}

fxy4 <- function (mod=modSexoff,predeffect='mean',df,ndraws=1) {

    reform <- ifelse(is.na(df$clone[1]),NA,'~(1|clone)')

    if (predeffect == 'mean') {
        R4 <- t(fitted(mod,df,type='response',re_formula=reform)[,1,drop=FALSE])
    } else if (predeffect == 'posterior') {
        ##R4 <- (posterior_predict(mod,df,type='response',ndraws=ndraws,re_formula=reform))
        R4 <- (posterior_linpred(mod,transform=TRUE,df,ndraws=ndraws,re_formula=reform))
    } else if (predeffect == 'glm') {
        R4 <- predict(mod,df,type='response')
    }

    return(R4)
}

dxy <- function (mod=modOffsize,predeffect='mean',df,ndraws=1) {

    reform <- ifelse(is.na(df$clone[1]),NA,'~(1|clone)')

    if (predeffect == 'mean') {
        pred <- t(fitted(mod,df,type='response',re_formula=reform)[,1,drop=FALSE])
    } else if (predeffect == 'posterior') {
        ##pred <- (posterior_predict(mod,df,ndraws=ndraws,re_formula=reform))
        pred <- (posterior_linpred(mod,transform=TRUE,df,ndraws=ndraws,re_formula=reform))
    } else if (predeffect == 'glm') {
        pred <- predict(mod,df,type='response')
    }

    return(pred)
}

buildVitalrates <- function (treatments,allsizes,
                             predeffect='mean',
                             ndraws=1) {

    ## All body sizes
    df <- data.frame(size=allsizes,size2=allsizes^2)

    ## Combine with treatments
    tmp <- as.data.frame(lapply(df, rep, each = nrow(treatments)))
    df <- cbind(tmp,treatments)
    df$tempSq <- df$temp
    
    ## Combine with males and females
    ##df <- as.data.frame(lapply(df, rep, each = 2))
    df$sex <- 'f' # only females ##rep(c('f','m'),nrow(df)/2)

    ## Survival
    cat('\r','Vital rate 1/7')
    P <- pxy(predeffect=predeffect,df=df,ndraws=ndraws)

    ## Growth
    cat('\r','Vital rate 2/7')
    growth <- gxy(predeffect=predeffect,df=df,ndraws=ndraws)

    ## Reproduction
    cat('\r','Vital rate 3/7')
    R1 <- fxy1(predeffect=predeffect,df=df,ndraws=ndraws)
    
    cat('\r','Vital rate 4/7')
    R2 <- fxy2(predeffect=predeffect,df=df,ndraws=ndraws)
    
    cat('\r','Vital rate 5/7')
    R3 <- fxy3(predeffect=predeffect,df=df,ndraws=ndraws)
    
    cat('\r','Vital rate 6/7')
    R4 <- fxy4(predeffect=predeffect,df=df,ndraws=ndraws)
    
    ## Offspring size
    cat('\r','Vital rate 7/7')
    offsize <- dxy(predeffect=predeffect,df=df,ndraws=ndraws)

    return(list(P=P,
                growth=growth,
                R1=R1,
                R2=R2,R3=R3,R4=R4,
                offsize=offsize,df=df))
}

createIPM <- function (allsizes,P,Pmale,growth,growthM,R1,R2,R3,R4,offsize,nc) {


  ## Survival
  P <- matrix(P,ncol=nc,nrow=nc,byrow=TRUE)
  ##Pmale <- matrix(Pmale,ncol=nc,nrow=nc,byrow=TRUE)
    
  ## Growth
  # omgerekened naar unscaled, as res is on unscaled values
  allsizesUnsc <- (allsizes * scSize[2]) + scSize[1]
  newsize <- allsizesUnsc + growth # predicted new size (in mm; unscaled)
  G <- sapply(1:length(newsize),function(x) {
    p <- dnorm(allsizesUnsc,newsize[x],resGrowth) * diff(allsizesUnsc[1:2])
    if (x < (length(newsize)/2)) {
      p[1] <- p[1] + (1-sum(p))
    } else {
      p[length(p)] <- p[length(p)] + (1-sum(p))
    }
    return(p)
  })

  ##newsize <- allsizesUnsc + growthM # predicted male new size (in mm; unscaled)
  ##Gmale <- sapply(1:length(newsize),function(x) {
  ##  p <- dnorm(allsizesUnsc,newsize[x],resGrowth) * diff(allsizesUnsc[1:2])
  ##  if (x < (length(newsize)/2)) {
  ##    p[1] <- p[1] + (1-sum(p))
  ##  } else {
  ##    p[length(p)] <- p[length(p)] + (1-sum(p))
  ##  }
  ##  return(p)
  ##})

    
  ## Reproduction
  R <- matrix(R1*R2*R3*R4,ncol=nc,nrow=nc,byrow=TRUE)
  ##Rmale <- matrix((R1*R2*R3*(1-R4)),ncol=nc,nrow=nc,byrow=TRUE)

  ## Offspring size
  D <- sapply(1:length(offsize),function(x) {
    p <- dnorm(allsizes,offsize[x],resOff) * cw
    p[1] <- p[1] + (1-sum(p))
    return(p)
  })


  # Convert to daily IPMs (to improve!)
  P <- P^(1/3.5)
  R <- R / 3.5 # simplification; could be improved
  ##Rmale <- Rmale / 3.5
  ##Pmale <- Pmale^(1/3.5)
  # growth is already per day
  # leave offspring size as is

  # Construct full IPM
  ipm <- P*G + R*D

  ##ipm <- magic::adiag(ipm,Pmale*Gmale)
  ##ipm[(nc+1):(2*nc),1:nc] <- Rmale*D

    return(list(ipm=ipm,G=G,P=P,D=D,R=R,R1=R1,R2=R2,R3=R3,R4=R4
                ##Gmale=Gmale,Pmale=Pmale,Rmale=Rmale
                ))
}


eigenAnalysis<-function (A, zero = TRUE) {
    ev <- eigen(A)
    lmax <- which.max(Re(ev$values))
    lambda <- Re(ev$values[lmax])
    W <- ev$vectors
    w <- abs(Re(W[, lmax]))
    eigenAnalysis <- list(lambda1 = lambda, stable.stage = w/sum(w))
}


################################################################################
## LOTKA VOLTERRA
################################################################################
# niche overlap
niche <- function(pars) {
  pars <- exp(pars)
  sqrt((pars['a21']*pars['a12']) / (pars['a11']*pars['a22']))
}
# competitive ability
comp <- function(pars) {
  pars <- exp(pars)
  sqrt((pars['a22']*pars['a21']) / (pars['a11']*pars['a12']))
}

getPars <- function (allpar,temp) {
  r1 <- allpar['r1'] + allpar['r1t'] * temp
  r2 <- allpar['r2'] + allpar['r2t'] * temp
  a11 <- allpar['a11'] + allpar['a11t'] * temp
  a12 <- allpar['a12'] + allpar['a12t'] * temp
  a21 <- allpar['a21'] + allpar['a21t'] * temp
  a22 <- allpar['a22'] + allpar['a22t'] * temp
  return(c(r1,r2,a11,a12,a21,a22))
}

LVFull <- function (params,times,y) {

  fun <- function (t,y,params) {
    x1 <- y[1]
    x2 <- y[2]

    with(as.list(params),{
      dx1 <- r1 * x1 * (1 - a11*x1 - a12*x2)
      dx2 <- r2 * x2 * (1 - a21*x1 - a22*x2)
      return(list(c(dx1,dx2)))
    })
  }

  out <- ode(y=y,times=times,func=fun,parms=params)
  return(out)

}

llFull <- function (params,pnames=paramnames,dat=datuse,weight=50) {

  allpred <- allprop <- rep(NA,nrow(dat))
  names(params) <- pnames

  ## Mono Belgian
  inc <- is.na(dat$pop2) & dat$country == 'B'
  pred <- LVFull(params=exp(params),y=c(12,0),times=dat$day[inc])
  tot <- rowSums(pred[,-1])
  allpred[inc] <- tot # total population size
  allprop[inc] <- pred[,2] / tot

  ## Mono Norwegian
  inc <- is.na(dat$pop2) & dat$country == 'N'
  pred <- LVFull(params=exp(params),y=c(0,12),times=dat$day[inc])
  tot <- rowSums(pred[,-1])
  allpred[inc] <- tot # total population size
  allprop[inc] <- pred[,2] / tot

  ## Mix populations
  inc <- !is.na(dat$pop2)
  if (sum(inc) > 0) {
    pred <- LVFull(params=exp(params),y=c(6,6),times=dat$day[inc])
    tot <- rowSums(pred[,-1])
    allpred[inc] <- tot # total population size
    allprop[inc] <- pred[,2] / tot
  }

  # likelihoods
  l1 <- sum(dpois(dat$n,allpred,log=TRUE),na.rm=TRUE) # population numbers
  l2 <- sum(dbinom(dat$countryBin,1,allprop,log=TRUE),na.rm=TRUE)

  if (!is.finite(l1)) l1 <- -1E10
  if (!is.finite(l2)) l2 <- -1E10

  #cat(params,'\n')
  return(l1 + l2*weight)
}

llFullTemp <- function (params,pnames=paramnames,dat=datuse,
                        weight=50) {

  allpred <- allprop <- rep(NA,nrow(dat))
  names(params) <- pnames
  allTemp <- unique(dat$temp)

  for (i in 1:length(allTemp)) { # over temperature

    pars <- exp(getPars(params,allTemp[i])) # temperature specific pars

    ## Mono Belgian
    inc <- is.na(dat$pop2) & dat$country == 'B' & dat$temp == allTemp[i]
    pred <- LVFull(params=pars,y=c(12,0),times=dat$day[inc])
    tot <- rowSums(pred[,-1])
    allpred[inc] <- tot # total population size
    allprop[inc] <- pred[,2] / tot

    ## Mono Norwegian
    inc <- is.na(dat$pop2) & dat$country == 'N' & dat$temp == allTemp[i]
    pred <- LVFull(params=pars,y=c(0,12),times=dat$day[inc])
    tot <- rowSums(pred[,-1])
    allpred[inc] <- tot # total population size
    allprop[inc] <- pred[,2] / tot

    ## Mix populations
    inc <- !is.na(dat$pop2) & dat$temp == allTemp[i]
    if (sum(inc) > 0) {
      pred <- LVFull(params=pars,y=c(6,6),times=dat$day[inc])
      tot <- rowSums(pred[,-1])
      allpred[inc] <- tot # total population size
      allprop[inc] <- pred[,2] / tot
    }

  }

  # likelihoods
  l1 <- sum(dpois(dat$n,allpred,log=TRUE),na.rm=TRUE) # population numbers
  l2 <- sum(dbinom(dat$countryBin,1,allprop,log=TRUE),na.rm=TRUE)
  #cat(l1,l2,'\n')
  if (!is.finite(l1)) l1 <- -1E10
  if (!is.finite(l2)) l2 <- -1E10

  return(l1 + l2*weight)
}


## Significance asterik for in figures
getAsterik <- function (p) {

    if (p > .05) {
        return('NS')
    } else if (p > .01) {
        return ('*')
    } else if (p > .001) {
        return ('**')
    } else {
        return ('***')
    }   
}

fig_label <- function(text, region="figure", pos="topleft", cex=NULL, ...) {

  region <- match.arg(region, c("figure", "plot", "device"))
  pos <- match.arg(pos, c("topleft", "top", "topright", 
                          "left", "center", "right", 
                          "bottomleft", "bottom", "bottomright"))

  if(region %in% c("figure", "device")) {
    ds <- dev.size("in")
    # xy coordinates of device corners in user coordinates
    x <- grconvertX(c(0, ds[1]), from="in", to="user")
    y <- grconvertY(c(0, ds[2]), from="in", to="user")

    # fragment of the device we use to plot
    if(region == "figure") {
      # account for the fragment of the device that 
      # the figure is using
      fig <- par("fig")
      dx <- (x[2] - x[1])
      dy <- (y[2] - y[1])
      x <- x[1] + dx * fig[1:2]
      y <- y[1] + dy * fig[3:4]
    } 
  }

  # much simpler if in plotting region
  if(region == "plot") {
    u <- par("usr")
    x <- u[1:2]
    y <- u[3:4]
  }

  sw <- strwidth(text, cex=cex) * 60/100
  sh <- strheight(text, cex=cex) * 60/100

  x1 <- switch(pos,
    topleft     =x[1] + sw, 
    left        =x[1] + sw,
    bottomleft  =x[1] + sw,
    top         =(x[1] + x[2])/2,
    center      =(x[1] + x[2])/2,
    bottom      =(x[1] + x[2])/2,
    topright    =x[2] - sw,
    right       =x[2] - sw,
    bottomright =x[2] - sw)

  y1 <- switch(pos,
    topleft     =y[2] - sh,
    top         =y[2] - sh,
    topright    =y[2] - sh,
    left        =(y[1] + y[2])/2,
    center      =(y[1] + y[2])/2,
    right       =(y[1] + y[2])/2,
    bottomleft  =y[1] + sh,
    bottom      =y[1] + sh,
    bottomright =y[1] + sh)

  old.par <- par(xpd=NA)
  on.exit(par(old.par))

  text(x1, y1, text, cex=cex, ...)
  return(invisible(c(x,y)))
}
