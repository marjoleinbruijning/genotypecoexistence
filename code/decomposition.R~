

##########################################################################################
## Vital rate decomposition
##########################################################################################

ind <- rep(list(rep('incF',7)),8)
for (z in 2:8) {ind[[z]][z-1] <- 'incF2'}

##indM <- rep(list(rep('incM',7)),8)
##for (z in 2:8) {indM[[z]][z-1] <- 'incM2'}

dN <- array(NA,dim=c(n,n,2,length(allTemp),length(changeVR),ndraws))
treatments <- expand.grid(nHetero=allN,nCon=allN,country=c('N','B'),
                          temp=allTemp,clone=NA)

vr <- buildVitalrates(treatments=treatments,
                      allsizes,
                      ndraws=ndraws,
                      predeffect='posterior')


## Build IPM for each combination
for (i in 1:nrow(treatments)) {

    incF <- vr$df$nHetero == treatments$nH[i] & vr$df$nCon == treatments$nC[i] &
        vr$df$country == treatments$country[i] &
        vr$df$temp == treatments$temp[i] &
        vr$df$sex == 'f'
    
    ##incM <- vr$df$nHetero == treatments$nH[i] & vr$df$nCon == treatments$nC[i] &
    ##    vr$df$country == treatments$country[i] &
    ##    vr$df$temp == treatments$temp[i] &
    ##    vr$df$sex == 'm'


    ## Which rows to select for other country
    incF2 <- vr$df$nHetero == treatments$nH[i] & vr$df$nCon == treatments$nC[i] &
        vr$df$country != treatments$country[i] & ## select other country
        vr$df$temp == treatments$temp[i] &
        vr$df$sex == 'f'
    
    ##incM2 <- vr$df$nHetero == treatments$nH[i] & vr$df$nCon == treatments$nC[i] &
    ##    vr$df$country != treatments$country[i] &
    ##    vr$df$temp == treatments$temp[i] &
    ##    vr$df$sex == 'm'

    for (k in 1:length(changeVR)) {

        for (j in 1:ndraws) {
            
            ipm <- createIPM(allsizes,
                             P=vr$P[j,get(ind[[k]][1])],
                             ##Pmale=vr$P[j,get(indM[[k]][1])],
                             growth=vr$growth[j,get(ind[[k]][2])],
                             ##growthM=vr$P[j,get(indM[[k]][2])],
                             R1=vr$R1[j,get(ind[[k]][3])],
                             R2=vr$R2[j,get(ind[[k]][4])],
                             R3=vr$R3[j,get(ind[[k]][5])],
                             R4=vr$R4[j,get(ind[[k]][6])],
                             offsize=vr$offsize[j,get(ind[[k]][7])],
                             nc=nc)
            
            ## Save in dN array to ease plotting
            if (treatments$country[i] == 'B') {
                dN[which(allN == treatments$nC[i]),
                   which(allN == treatments$nH[i]),1,
                   which(allTemp == treatments$temp[i]),k,j] <- eigenAnalysis(ipm$ipm)$lambda
                ## If Belgian
                
            } else {
                dN[which(allN == treatments$nH[i]),
                   which(allN == treatments$nC[i]),2,
                   which(allTemp == treatments$temp[i]),k,j] <- eigenAnalysis(ipm$ipm)$lambda
                ## If Norwegian
            }

            cat('\r',i,'-',j,'-',k)

        }  

    }
}

saveRDS(dN,file='Results/decomposition.rds')





##########################################################################################
##########################################################################################
##########################################################################################
old <- function () {

    ## save output
dN <- array(NA,dim=c(n,n,2,length(allTemp),length(changeVR)))

for (k in 1:length(allTemp)) {

    temp <- allTemp[k]

    for (m in 1:length(changeVR)) {
        
        for (i in 1:n) { ## vary Norwegian pop sizes
            for (j in 1:n) { ## Vary Belgian pop sizes

                ## Belgian change in density
                ipm1 <- createIPM(allsizes,
                                  temp=temp,
                                  nH=allN[i],
                                  nC=allN[j],
                                  nSc=NA,
                                  country='B',
                                  country2='N',
                                  changeVR=changeVR[[m]])

                ## Norwegian change in density
                ipm2 <- createIPM(allsizes,
                                  temp=temp,
                                  nH=allN[j],
                                  nC=allN[i],
                                  nSc=NA,
                                  country='N',
                                  country2='B',
                                  changeVR=changeVR[[m]])

                ## only female part for lambda
                dN[j,i,1,k,m] <- eigenAnalysis(ipm1$ipm[1:nc,1:nc])$lambda
                dN[j,i,2,k,m] <- eigenAnalysis(ipm2$ipm[1:nc,1:nc])$lambda
                
                cat('\r',i,'-',j)
            }
        }
    }
}
saveRDS(dN,file='Results/decomposition.rds')

    
##pdf('Results/decomposition.pdf')
## Coexistence plot
allniches <- seq(0,1,length.out=1001)
allk <-  seq(0,2.5,length.out=500)

mat <- outer(allniches,allk,
             function(x,y) x < y & y < 1/x)

image(allniches,allk,mat,
      xlab='',ylab='',col=c('white','white'),cex.axis=1.5)
contour(allniches,allk,mat,labels='',add=TRUE,lwd=3,col='grey')

mtext('Niche overlap',1,line=2)
mtext('Fitness difference',2,line=2)

## Add  vital rate lines
cols <- c('black','#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628')
nicheoverlap <- fitnessdiff <- propb <- matrix(NA,nrow=length(changeVR),ncol=length(allTemp))

for (m in 1:length(changeVR)) {


    for (k in 1:length(allTemp)) {
        ## Fit linear lines to obtain alpha coefficients
        mod <- list()
        for (i in 1:2) {
            df <- contourLines(allN,allN,dN[,,i,k,m],levels=1)
            df <- data.frame(n2=df[[1]]$y,n1=df[[1]]$x)
            mod[[i]] <- lm(n2~n1,data=df)
        }
        ##  Get coefficients
        pars <- c(a11=NA,a12=NA,a21=NA,a22=NA)
        pars['a12'] <- 1/coef(mod[[1]])[1]
        pars['a11'] <- 1/ (-(coef(mod[[1]])[1]) / (coef(mod[[1]])[2]))

        pars['a22'] <- 1/coef(mod[[2]])[1]
        pars['a21'] <- 1/ (-(coef(mod[[2]])[1]) / (coef(mod[[2]])[2]))

        nicheoverlap[m,k] <- sqrt((pars['a21']*pars['a12'])/(pars['a11']*pars['a22']))
        fitnessdiff[m,k] <- sqrt((pars['a21']*pars['a22'])/(pars['a11']*pars['a12']))

        ## Predict eq proportions (where do nullclines intersect?)
        beq <- (coef(mod[[1]])[1] - coef(mod[[2]])[1]) / ( coef(mod[[2]])[2] - coef(mod[[1]])[2] )
        neq <- predict(mod[[1]],newdata=data.frame(n1=beq))

        if (beq < 0) beq <- 0
        if (neq < 0) neq <- 0
        propb[m,k] <- beq / (beq + neq)

    }
    
    lines(nicheoverlap[m,],fitnessdiff[m,],col=cols[m],lwd=3)
    points(nicheoverlap[m,1],fitnessdiff[m,1],col=cols[m],cex=1.5,pch=16)
}

namess <- c('Original','Surival','Growth','Carrying eggs','Egg development','Clutch size',
  'Female probability','Offspring size')
legend('topleft',col=cols,bty='n',lwd=2,legend=namess)

dev.off()


## Stacked barplot contribution niche overlap and fitness difference
rownames(nicheoverlap) <- rownames(fitnessdiff) <- rownames(propb) <- namess
cols <- rev(c('#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17'))
toplot <- c('nicheoverlap','fitnessdiff','propb')

par(mfrow=c(2,2))
for (i in 1:3) {
    
    y <- get(toplot[i]) 

    contrib <- apply(y,2,function (x) {
        eff <- x - x[1]
        contrib <- abs(eff) / sum(abs(eff))  # proportional absolute importance
        contrib
    })

    ## positive or negative effect?
    direc <- apply(y,2,function (x) {
        eff <- x - x[1]
        eff > 0
    })


    if (i == 1) orderr <- order(rowMeans(contrib)) # sort by average importance
    
    contrib <- contrib[orderr,]
    direc <- direc[orderr,]

    cumsums <- apply(contrib,2,cumsum)

    plot(100,100,xlim=range(allTemp*scTemp[2]+scTemp[1]),ylim=c(0,1),bty='l',
         xlab='',ylab='Importance for competitive outcome',xaxs="i",yaxs='i')
    for (i in 2:nrow(cumsums)) {
        polygon(x=c(allTemp*scTemp[2]+scTemp[1],rev(allTemp*scTemp[2]+scTemp[1]),allTemp[1]*scTemp[2]+scTemp[1]),
                y=c(cumsums[i-1,],rev(cumsums[i,]),cumsums[i-1,][1]),col=cols[i-1],border=NA)

                                        # add shading when positive effect
        x <- allTemp[direc[i,]]*scTemp[2]+scTemp[1]
        y1 <- cumsums[i-1,][direc[i,]]
        y2 <- cumsums[i,][direc[i,]]
        polygon(x=c(x,rev(x),x[1]),
                y=c(y1,rev(y2),y1[1]),density=15,border=NA)
    }
    legend('bottomright',bty='n',legend=c('A','B')[i],cex=1.5)
}

legend('topright',col=rev(cols),lwd=2,legend=rev(rownames(contrib)[-1]),box.lwd = 0,
  box.col = "#ffffff70",bg = "#ffffff70",cex=.6)

legend("topleft", legend=c('Belgian benefit','Norwegian benefit'),
  fill=c(NA,NA),
  density=c(1, 30), bty="n",border=c("black", "black"),cex=1,
  box.lwd = 0,
  box.col = "#ffffff70",bg = "#ffffff70",pt.cex=2)


mtext('Temperature',1,outer=TRUE,line=2)

}
